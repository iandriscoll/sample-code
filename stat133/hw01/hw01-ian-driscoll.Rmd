---
title: "Homework 1 Ian Driscoll"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
### 1. Data Dictionary

The file 'imports-85-dictionary.md' has been created in the hw01 directory and specifies what each of the variables mean.  

### 2. Data Import

```{r}
library(readr)
names = c('symboling', 'normalized_losses', 'make', 'fuel_type', 'aspiration', 'num_of_doors', 'body_style', 'drive_wheels', 'engine_location', 'wheel_base', 'length', 'width', 'height', 'curb_weight', 'engine_type', 'num_of_cylinders', 'engine_size', 'fuel_system', 'bore', 'stroke', 'compression_ratio', 'horsepower', 'peak_rpm', 'city_mpg', 'highway_mpg', 'price')
dat = read_csv('imports-85.data', col_names = names, col_types = 'ddcccccccddddiccicdddiiiii', na = c('?'))
str(dat)
```

### 3. Technical Questions About Importing Data

a. When you call read.csv('imports-85.data'), the names of the columns will default to the first entry in the column. If the value is an integer or numeric value, it will read "X(value)", the exact chzracter string if it is a character, and X. if it is a missing value.

b. If you set header to FALSE, the labels for the columns become V1, V2, V3, ... until the last column.

c. These columns are coerced into characters if there are missing values if strongsAsFactors is set to FALSE, and are coerced to factors if not. 

d. When the values are specified for data types of columns, the missing values make errors and are converted from "?" to "NA" which increases the overall file size.

e. An R matrix can only be one data type for all columns and values, so everything would be converted to a character. Because the data is not all integers or numerics, they all are converted to characters.

### 4. Practice Base Plotting

```{r price}
hist(dat$price, col = 'Orange', xlab = 'Price', main = 'Histogram of Price')
```

```{r horsepower}
boxplot(dat$horsepower, horizontal = TRUE, main = 'Horsepower', xlab = 'Horsepower')
```
```{r body style}
bs_table = table(dat$body_style)
bs_data_frame = as.data.frame(bs_table)
bs_ordered = bs_data_frame[order(bs_data_frame$Freq, decreasing = TRUE), ]
barplot(bs_ordered$Freq, width = 1.8, xlim = c(0, 10), ylim = c(0, 120), names.arg = bs_ordered$Var1)
```

```{r stars}
turbo = dat[dat$aspiration == 'turbo', c('wheel_base', 'length', 'width', 'height', 'price')]
stars(turbo, main = 'Turbo Vehicles')
```

### 5. Summaries

```{r}
# a.
gas_price = dat[dat$fuel_type == 'gas' & !is.na(dat$price), 'price']
mean(gas_price$price)
# b.
twelve_cyl = dat[dat$num_of_cylinders == 'twelve', 'make']
twelve_cyl$make[1]
# c.
diesel = dat[dat$fuel_type == 'diesel',]
diesel_table = table(diesel$make)
diesel_df = as.data.frame(diesel_table, stringsAsFactors = FALSE)
diesel_df_ordered = diesel_df[order(diesel_df$Freq, decreasing = TRUE), ]
diesel_df_ordered$Var1[1]
# d.
hp_ordered = dat[order(dat$horsepower, decreasing = TRUE), ]
hp_ordered$price[1]
# The price for the largest horsepower is missing, so I will check the second highest horsepower.
hp_ordered$price[2]
# e.
quantile(dat$city_mpg, probs = 0.1)
# f.
quantile(dat$highway_mpg, probs = 0.9)
# g.
price_10th = dat[dat$city_mpg <= 17 & !is.na(dat$price), 'price']
median(price_10th$price)
```

### 6. Technical Questions About Data Frames

a. The output would return NULL since it does not exist, and a waarning message would be displayed saying the column specified is unknown or uninitialised.

b. The fourth command would result in an error.

c. Since R is treating mpg as a variable, not the string title of a column, the object would not be found, causing an error when trying to call it.

d. Yes yoou can, but it does not translate directly to a data frame. A list is essentially one value, so a list column would essentially have one row. If a data frame is made with other columns of longer length, the list is copied to each row, and the list is further split up into separate columns for each entry in the list.

e. You can convert a data frame to a list, and it becomes a list with a length of the number of columns, and each entry in the list is a list itself, made up of the entries for each column.

f. One function you could use is as.data.frame(abc). Another function that would work is data.frame(label = abc).

### 7. Correlations of Quantitative Variables

```{r}
library(corrplot)
qdat = na.omit(dat)[ , c('wheel_base', 'length', 'width', 'height', 'curb_weight', 'engine_size', 'bore', 'stroke', 'compression_ratio', 'horsepower', 'peak_rpm', 'city_mpg', 'highway_mpg', 'price')]
correlation = cor(qdat)
# color visualization
corrplot(correlation, method = "color")
# number visualization
corrplot(correlation, method = "number")
```

Looking at the visualizations of the correlation matrix, it appears that price is positively correlated with many of the physical characteristics such as length, width, and height. However, city_mpg and highway_mpg appear to be negatively correlated with those attributes, suggesting an inverse correlation between price and mpg, which is apparent in the -0.69 and -0.72 correlations with between the mpg's and price.

### 8. Principal Component Analyis

```{r}
pca = prcomp(qdat, scale. = TRUE)
pca
eigenvalues = pca$sdev^2
percentage = (eigenvalues / sum(eigenvalues)) * 100
cum_percent = cumsum(percentage)
eigenframe = data.frame(eigenvalue = eigenvalues, percentage = percentage, cum_percent = cum_percent
)
eigenframe
eigenframe$cum_percent[3]
# First two components plot
plot(pca$x, main = 'PC1 vs. PC2')
# First two loadings plot
plot(pca$rotation[,1], pca$rotation[,2], xlab = 'PC1', ylab = 'PC2', main = 'Loadings of PC1 vs. PC2')
text(pca$rotation[,1], pca$rotation[,2], labels=names(qdat), cex= 0.7)
```

Looking at the first scatterplot, it appears that most of the scores are clustered around 0 for both variables, but there is a larger proportion of variables with higher than average PC2 scores. In the second scatterplot we can see that many of the variables are around clustered around 0 for PC2, but around -0.3 for PC1.